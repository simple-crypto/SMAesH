\documentclass{scrartcl}

\usepackage{todonotes}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{float}
\usepackage{siunitx}

\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{xspace}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{tabularx}

\usepackage{tablefootnote}

\usepackage{geometry}
\geometry{top=2cm, bottom=2cm, left=2.5cm, right=2.5cm}

\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\footnotesize,
  mathescape
}

%\usepackage[left=3cm, right=3cm, bottom=3cm, top=3cm]{geometry}

\usepackage{dirtree}
\usepackage{tikz}
\usepackage{figures/tikz-timing}
\usepackage{circuitikz}
\usepackage{xcolor}
\usetikzlibrary{shapes.symbols}

\input{macros}
\input{figures/tikzset_cfg.tex}

\title{SMAesH: technical documentation}
\subtitle{Masked Hardware AES with HPC}
\author{SIMPLE-Crypto}
\date{}

\begin{document}
\input{figures/tikz_color}

\maketitle

\tableofcontents

\section{Overview}
\label{section:overview}
This document describes SIMPLE-Crypto's Masked AES in Hardware (SMAesH),
implemented in the $\topName$ hardware IP. 

\section{History}
\begin{description}
    \item[2.0.0 (2024-10-08)] Major (breaking API) update: add AES-192, AES-256 and decryption .
    \item[1.1.0 (2024-09-02)] 4 cycles Canright S-box (new optimized architecture).
    \item[1.0.1 (2023-06-15)] Fix latency in Section 5.4 (documentation change only).
    \item[1.0.0 (2023-05-01)] Initial release.
\end{description}

\section{Features}
The \core{} module is a masked hardware implementation of the three variants of
the AES algorithm as specified in \cite{nist197}. In particular, the core
implements the encryption as well as the decryption for the variants using
128-bit, 192-bit and 256-bit keys.  

\begin{itemize}
\item{The core implements the AES-128, AES-192, AES-256 encryption and decryption function, chosen dynamically at run-time.}
\item{The implementation is protected against side-channel attacks using a combination of HPC1~\cite{DBLP:journals/tc/CassiersGLS21} and HPC3~\cite{DBLP:conf/ccs/Knichel022} masking scheme.}
\item{The core relies on an internal long-term key, configured at run-time. The key configuration also defines the execution performed by the core (e.g., encryption vs decryption or algorithm version used).}
\item{The amount of shares $d\ge 2$ can be chosen at synthesis time.\footnote{While feasible, the architecture of the S-box is optimized and automatically generated for a given amount of shares. Therefore, changing the amount of share without re-generating the S-box may lead to suboptimal results. See~\ref{section:masked_aes_core_arhcitecture} for more details.}}
\item{The randomness required for the masking scheme is internally generated using an embedded PRNG.}
\item{The core is controlled through four simple valid-ready stream interfaces (input key, input data, output data and PRNG seed.}
\item{The core has an encryption latency of 86, 201 and 118 cycles for respectively AES-128, AES-192 and AES-256. The corresponding throughput is one 128-bit block of data per 86, 201 and 118 cycles.}
\item{The core has a decryption latency of 86, 121 and 118 cycles for respectively AES-128, AES-192 and AES-256. The corresponding throughput is one 128-bit block of data per 86, 121 and 118 cycles.}
\item{A key change comes with a latency penalty of $16d$ cycles. For decryption only, an additional penalty of $16$ cycles plus the latency of an encryption is paid.}
\item{The state of the core is automatically cleared when encryption finishes.}
\item{The key is automatically refreshed after each usage without latency penalty.}
\item{The AES-192 version comes together with the AES-256 version without paying additional logic other than control.}
\item{The AES-192 and AES-256 version can be disabled at synthesis time. }
\end{itemize}

\section{Core User Guide} 
\label{section:svrs_usage}

A top-level view of the core is shown in Figure~\ref{fig:top_module_view_ports}
and a detailed list of the ports is given in Table~\ref{table:ports}.  The
interface is composed of four independent interfaces: the key configuration
input (in violet), the input plaintext/ciphertext (in red), the
ciphertext/plaintext output (in blue) and the PRNG seed (in green).
The key (\svrsKey) is a 32-bit bus while the input (\svrsInData) and the output (\svrsOutData)
are 128-bit masked values.
The internal PRNG seed (\svrsSeed) is 80-bit wide.

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{
        \small
        \begin{tikzpicture}
            \input{figures/tikz_fig_top_module}
        \end{tikzpicture}
    }
    \caption{Top level view of module $\topName$.}
    \label{fig:top_module_view_ports}
\end{figure}

\input{figures/table_ports.tex}

In this section we next detail the operation of the Synchronous Valid-Ready
Stream (SVRS) protocol for the data interfaces, the operation of the $\topName$
core, and the masked data encoding.

\subsection{SVRS protocol}

\begin{figure}
    \centering
    \begin{tikztimingtable}
        \texttt{clock} & L 6{HL} \\
        \texttt{data} & X XX{} 3{DD}{}XXXX \\
        \texttt{valid} & L LL 3{HH} LLLL \\
        \texttt{ready} & L 3{LL} HH LLLL \\
        \extracode
        \makeatletter
        \begin{pgfonlayer}{background}
            \begin{scope}[gray,semitransparent,semithick]
                \foreach \x in {1,3,...,11}
                \draw (\x,1.5) -- (\x,-6.5);
            \end{scope}
        \end{pgfonlayer}
    \end{tikztimingtable}
    \caption{SVRS transaction (don't care (X) signals are represented with a flat red solid line).}
    \label{fig:basic_svrs}
\end{figure}


\begin{figure}
    \centering
    \begin{tikztimingtable}
        \texttt{clock} & L 13{HL} \\
        \texttt{data} & X 1{XX}{} 2{DD}{} 1{DD}{} 1{XX} {} 3{DD}{} 3{XX} DD XX \\ 
        \texttt{valid} & L 1{LL} 3{HH} 1{LL} 3{HH} 1{LL} 2{LL} 1{HH} LL\\
        \texttt{ready} & L 2{LL} 3{HH} 2{LL} 1{HH} 1{LL} 3{HH} 1{LL}\\
        \extracode
        \makeatletter
        \begin{pgfonlayer}{background}
            \begin{scope}[gray,semitransparent,semithick]
                \foreach \x in {1,3,...,25}
                \draw (\x,1.5) -- (\x,-6.5);
            \end{scope}
        \end{pgfonlayer}
    \end{tikztimingtable}
    \caption{Multiple SVRS transactions.}
    \label{fig:seq_svrs}
\end{figure}

The Synchronous Valid-Ready Stream (SVRS) protocol operates between a sender and a receiver.
The bus is composed of the two control signals \texttt{valid} and \texttt{ready}, as well as any number of \texttt{data} wires.
The \texttt{valid} and \texttt{data} signals are outputs (resp. inputs) of the
sender (resp. receiver), while the \texttt{ready} signal is an input (resp.
output) of the sender (resp. receiver).

The bus operates synchronously with an event source shared by the sender and
the receiver (here, the positive edges of the clock).
At each event, a transaction occurs if both \texttt{valid} and \texttt{ready}
are asserted (i.e. set to logical~1). The transmitted data of the transaction is
the value of the \texttt{data} signals at the event.

Once \texttt{valid} is asserted, it cannot be de-asserted (i.e., sticky signal), nor can the value of
\texttt{data} be changed until a transaction occurs.
To prevent deadlocks, a sender must not wait until the assertion of
\texttt{ready} before asserting \texttt{valid}.
To prevent combinational logic loops, the \texttt{valid} signal may not
combinationally depend on the \texttt{ready} signal.

Examples of protocol use are given in Figures~\ref{fig:basic_svrs} and~\ref{fig:seq_svrs}.


\subsection{Core Usage}
\label{section:core_usage}

\paragraph{Key configuration}
An new key is configured in the core by executing several transactions on the
key interfaces.  The configuration of a key of $\KEYSIZE$ bits (128, 192 or
256) is done by performing $d\cdot\KEYSIZE / 32$ transactions.  Each
transaction allows transferring 32 bits of key share. The transactions must be
performed such that the key shares are transferred sequentially, 32-bit word per
32-bit word, from the least significant word to the most significant one. The
key size and the inverse configuration are specified during the first
transaction. These configurations will then be hold internally to the core in
order to configure all the executions following the key configuration. In order
to configure the core in decryption mode, the signal $\svrsKeyModeInverse$
signal must be asserted during the first transaction. in such case, the core
internally computes the key of the last round after having fetched the key
value and stores it as the long term key.  
The Figure~\ref{fig:srvs_key_cfgd2} depicts an example of key configuration for the 128-bit key
$\texttt{umsk\_key}$, encoded in the 2-shares sharings $\texttt{share0\_key}$ and
$\texttt{share1\_key}$.   

\begin{figure}
    \centering
    \def\scaleFont{0.5}
    \begin{tikztimingtable}
        \texttt{\texttt{umsk\_key}} & 17{DD}{0x0f0e0d0c\_0b0a0908\_07060504\_03020100} \\
        \texttt{\texttt{share0\_key}} & 17{DD}{0x2a082ca6\_58197c74\_6395f678\_7f02d885} \\
        \texttt{\texttt{share1\_key}} & 17{DD}{0x250621aa\_5313757c\_6493f37c\_7c00d985} \\
        \\
        \texttt{clock} & L 17{HL} \\
        \svrsKey & X  2{DD}{\scalebox{\scaleFont}{7f02d885}} 2{DD}{\scalebox{\scaleFont}{6395f678}} 1{XX} 1{DD}{\scalebox{\scaleFont}{58197c74}} 1{XX} 1{DD}{\scalebox{\scaleFont}{2a082ca6}} 2{DD}{\scalebox{\scaleFont}{7c00d985}} 2{DD}{\scalebox{\scaleFont}{6493f37c}} 2{DD}{\scalebox{\scaleFont}{5313757c}} 2{DD}{\scalebox{\scaleFont}{250621aa}} 1{XX} \\ 
        \svrsKeySizeCfg & X  2{DD}{0} 15{XX} \\ 
        \svrsKeyModeInverse & X 2{LL} 15{XX}  \\ 
        \svrsKeyValid & L 4{HH} 1{LL} 1{HH} 1{LL} 3{HH} 6{HH} 1{LL} \\ 
        \svrsKeyReady & L 1{LL} 1{HH} 1{LL} 1{HH} 1{LL} 1{HH} 1{LL} 1{HH} 1{LL} 1{HH} 1{LL} 3{HHLL}\\
        \extracode
        \makeatletter
        \begin{pgfonlayer}{background}
            \begin{scope}[gray,semitransparent,semithick]
                \foreach \x in {1,3,...,32}
                \draw (\x,1.5) -- (\x,-19.5);
            \end{scope}
        \end{pgfonlayer}
    \end{tikztimingtable}
    \caption{Example of configuration of a 128-bit key for encryption}
    \label{fig:srvs_key_cfgd2}
\end{figure}

\paragraph{Encryption and decryption}
An encryption (resp. decryption) is started by executing a transaction on the input interface.
The execution is performed using the internally stored shared long term key and an input plaintext (resp. decryption) provided in the
transaction, then the \texttt{out} interface becomes valid, with the shared
ciphertext (resp. plaintext) as data.

The core can only perform one execution at a time and will not start a new
execution before the ciphertext/plaintext of the current encryption/decryption has been consumed from
the \texttt{out} interface.
Figure~\ref{fig:ex2runs} illustrates the interface signal for two consecutive encryptions.

\emph{Security:}
The $\svrsOutData$ is gated to not expose any confidential value when
$\svrsOutValid$ is not asserted.

\emph{Initialization:}
After reset, the core will not start an execution before it is re-seeded.

\emph{Latency and throughput:}
The AES implementation has a latency of 86~clock cycles. To achieve the
maximum throughput of one encrypted block per 86~cycles, there must be no
back-pressure (i.e., $\portAESOutReady$ must be high at the clock cycle where
$\portAESOutValid$ becomes asserted) and the input must be valid
($\portAESInValid$ asserted) at least one cycle before $\portAESOutValid$ is
asserted.

\begin{figure}
    \centering
    \begin{tikztimingtable}
        \texttt{clk} & L4{HL}SS5{HL}SS5{HL}\\
        \texttt{syn\_rst} & L16{LL} \\
        \\
        \svrsInData & X 2{DD}{$p_0$}{}7{DD}{$p_1$} 1{XX} 6{XX}\\
        \svrsInValid & L 4{HH} 4H 6H 1{LL} 6{LL}\\
        \svrsInReady & L LL 1{HH} 2{LL} 4L 4L 2H 2L 3{LL} 3{HH}\\
        \\
        \svrsSeed & X 4{XX} 6X 6X 6{XX}\\
        \svrsSeedValid & {}L 4{LL} 6L 6L 6{LL}\\
        \svrsSeedReady & {}X 16{XX} \\
        \\
        \svrsKey & X 16{XX} \\
        \svrsKeySizeCfg & X 16{XX} \\
        \svrsKeyModeInverse & X 16{XX} \\
        \svrsKeyValid & L 16{LL} \\
        \svrsKeyReady & X 16{XX} \\
        \\
        \svrsOutData & D 4{DD}4D{0} 4D{$c_0$} 4{DD}{0} 1{DD}{$c_1$} 3{DD}{0}\\
        \svrsOutValid & L 4{LL} 4L 4H 4L 4L 2H 3{LL}\\
        \svrsOutReady & L 4{LL} 4L 2L2H 4L 2L 4H 3{LL}\\
        \extracode
        \makeatletter
        \begin{pgfonlayer}{background}
            \node[draw=none] at (10,0.5) {\dots};
            \node[draw=none] at (22,0.5) {\dots};
            \begin{scope}[gray,semitransparent,semithick]
                \foreach \x in {1,3,...,7}
                \draw (\x,1.5) -- (\x,-38.5);
                \foreach \x in {11,13,...,19}
                \draw (\x,1.5) -- (\x,-38.5);
                \foreach \x in {23,25,...,31}
                \draw (\x,1.5) -- (\x,-38.5);
            \end{scope}
        \end{pgfonlayer}
    \end{tikztimingtable}
    \caption{Exemplary interface view for two executions (note that $\svrsSeedValid$ and $\svrsKeyValid$ are LOW).}
    \label{fig:ex2runs}
\end{figure}

\paragraph{(Re-)seeding}

The \texttt{seed} interface is used to re-seed the internal PRNG (this
PRNG generates the internal masking randomness, see
Section~\ref{subsection:PRNG} for details).
A re-seed is executed by means of a transaction on the \texttt{seed} interface,
as shown in Figure~\ref{fig:exreseed}.
During this transaction, the provided seed data \texttt{must} be uniform
randomness (i.e. all the bits must be fresh, uniform and independent).
After a re-seed transaction, the re-seeding procedure lasts for a few cycles (the
duration depends on the core configuration, it is typically less than a dozen
cycles). 

\paragraph{Interactions between key configuration, execution and re-seeding}
\begin{itemize}
    \item After a reset, the core does not start any execution/key configuration before being re-seeded once. 
    \item The core will not accept a re-seed transaction while it is executing (encryption/decryption) or when a key is under configuration.
    \item The core will not accept a key configuration transaction while it is executing (encryption/decryption) or when a re-seeding is ongoing.
    \item The core will not start an execution while it is re-seeding or configuring a new key.
    \item Starting a new execution takes precedence over starting a re-seed or configuring a new key.
        Hence, if re-seeding or configuring a new key is needed, no new valid input should be asserted
        before a re-seed/key configuration transaction happens.
    \item Starting a re-seeding takes precedence over starting a new key configuration. Therefore, if configuring a new key is required, no new 
        seed valid input should be asserted before the first key configuration transaction occurred.
\end{itemize}

\begin{figure}
    \centering
    \begin{tikztimingtable}
        \texttt{clk} & L4{HL}SS3{HL}SS4{HL}\\
        \texttt{syn\_rst} & L13{LL} \\
        \\
        \svrsPlaintext & X 2{DD}{$p_0$}{}5{DD}{$p_1$} 6{DD}{$p_2$}\\
        \svrsKey & X 2{DD}{$k_0$}{}5{DD}{$k_1$} 6{DD}{$k_3$} \\
        \svrsInValid & L 4{HH} 3{HH} 6{LL} \\
        \svrsInReady & L LL 1{HH} 4{LL} 1{HH} 6{LL}\\
        \\
        \svrsSeed & X 2{XX} 10{DD}{$s_0$} XX\\
        \svrsSeedValid & {}L 2{LL} 10{HH} LL\\
        \svrsSeedReady & {}L 11{LL} HH LL \\
        \\
        \svrsCiphertext & D 5{DD}{0} 1{DD}{$c_0$} 3{DD}{0} 1{DD}{$c_1$} 3{DD}{0}\\
        \svrsOutValid & L 5{LL} HH 3{LL} HH 3{LL}\\
        \svrsOutReady & L 2{LL} 11{HH}\\
        \extracode
        \makeatletter
        \begin{pgfonlayer}{background}
            \node[draw=none] at (10,0.5) {\dots};
            \node[draw=none] at (18,0.5) {\dots};
            \begin{scope}[gray,semitransparent,semithick]
                \foreach \x in {1,3,...,7}
                \draw (\x,1.5) -- (\x,-28.5);
                \foreach \x in {11,13,...,15}
                \draw (\x,1.5) -- (\x,-28.5);
                \foreach \x in {19,21,...,25}
                \draw (\x,1.5) -- (\x,-28.5);
            \end{scope}
        \end{pgfonlayer}
    \end{tikztimingtable}
    \caption{Exemplary re-seeding procedure.}
    \label{fig:exreseed}
\end{figure}

\subsection{Sharing encoding}
\label{sec:share_encoding}

The busses $\svrsInData$ and
$\svrsOutData$ contain respectively the shared representation of the
plaintext, the key and the ciphertext.

A sharing (or shared representation) of a bit $b$ is a tuple of $d$ shares
$\left(b^0, b^1, \dots, b^{d-1} \right)$ such that $\bigoplus_{m,0\leq m<d} b^m = b$.
The sharing of a $n$-bit bus
$\texttt{data}\left[ n-1:0\right]$ where $\texttt{data}[i]=b_i$
is
$\texttt{shares\_data}\left[ nd-1:0 \right]$ where
$\texttt{shares\_data}\left[ ni+j\right] = b_i^j$ and
$\left(b_i^0, \dots, b_i^{d-1}\right)$ is a sharing of $b_i$.
This representation is illustrated in Figure~\ref{fig:encoding}.

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{
        \begin{tikzpicture}
            \input{figures/tikz_bus_encoding}
        \end{tikzpicture}
    }
    \caption{Encoding of a shared $n$-bit wide data with $d$ shares.}
    \label{fig:encoding}
\end{figure}

The key and the input data must be fed as uniform sharings (i.e. the sharing is
selected uniformly at random among possible sharings that represent the correct
value). The output data sharing is guaranteed to be uniform.

\section{Core Architecture}
\label{section:architecture}

The top-level architecture of $\topName$ is depicted in Figure~\ref{fig:smaesh_top_module}:
its main components are the AES unit $\topModAES$, the key storage unit $\topModKHOLD$ and the PRNG. Some additional logic
is used to handle the execution/key configuration/re-seed interlocking, as well as units to shuffle
the shares of the masked busses.

\paragraph{Core}
The module $\topModAES$ implements a masked version of the three variants of
the AES algorithm, in encryption or decryption, by serially processing 32-bits
parts of the state and chosen at run-time. The execution is internally
configured by the $\topModKHOLD$ module that forwards the signals
$\portAESModeI$ and $\portAESModeII$ to select another version than the 128-bit
one used by default and the signal $\portAESInverse$ that specifies that the
reverse algorithm must be executed. It runs a single AES execution at a time
and the output produced ($\portAESOutData$) has to be fetched before a new
execution can start. Together with the configuration signals, the shared input ($\portAESInData$) and the shared key
($\portAESInKey$) are fetched at the beginning of a new execution by performing
a simple transaction at the input interface (with $\portAESInValid$ and
$\portAESInReady$).  Similarly, the shared output ($\portAESOutData$) is output
from the core with a dedicated interface (with $\portAESOutValid$ and
$\portAESOutReady$). The signal $\portAESbusy$ is asserted when an execution is
ongoing inside the core.
Finally, the signals $\portAESKSchedOnly$, $\portAESLastKeyColPreValid$, 
$\portAESLastKeyCol$ and $\portAESRndRfValid$ are only used internally together with the key storage module $\topModKHOLD$ in order to perform specific operation 
related to the key management as detailed in the paragraph "Key Holder" below. 

\paragraph{PRNG}
The module $\topModPRNG$ is generating the randomness required by the 
masking scheme. It is the producer on the randomness bus, while $\topModAES$ is
the receiver.

When not re-seeding, it takes only a single cycle to generate the fresh randomness, therefore
at the next cycle after a randomness transaction, new randomness is already available (i.e.,
$\portAESRnd$ carries fresh randomness, and $\portPrngOutValid$ is asserted).
During an encryption, $\topModAES$ needs randomness at all clock cycles, hence
it keeps $\portPrngOutReady$ asserted, and thanks to the high-throughput
capability of the PRNG, a transaction happens on the randomness bus at every
clock cycles ($\portPrngOutValid$ stays asserted).

This high throughput capability is actually relied upon by $\topModAES$: it
needs randomness for security at every cycle during the encryption
and cannot stall once encryption is started.
The signal $\portPrngOutValid$ is de-asserted only when the PRNG has not been
seeded after a reset, or while it is re-seeding.
To ensure that fresh randomness is always available when encrypting, the
interlocking logic prevents the $\topModAES$ from starting an encryption if
$\portPrngOutValid$ is de-asserted, while it prevents $\topModPRNG$ from
starting a re-seed when an encryption is ongoing.
If no encryption is ongoing and $\svrsSeedValid$ is asserted, then a re-seed is
initiated and a transaction on the \texttt{seed} bus occurs at the next cycle
(this is to avoid a combinational dependency $\svrsSeedValid \rightarrow
\svrsSeedReady$, and is achieved by detecting a rising edge on the PRNG
$\portPrngBusy$ signal).

\paragraph{Key holder}
The module $\topModKHOLD$ is in charge of the key management and the
configuration of the executions performed by the core. This module is mainly
keeping the shares values of the long term key and is in charge of refreshing
the latter after each execution of the core. A new key value is configured
serially by performing transactions of 32-bit piece of data on the key
dedicated interface (i.e., $\portKHDataIn$, $\portKHDataInValid$ and
$\portKHDataInReady$). Besides the key value, the key size (i.e., 128, 192 or
256 bits) is configured during the first transaction of a new key configuration
using the signal $\portKHSizeCfg$ (i.e., 0b00 for 128, 0b01 for 192 and 0b11
for 256). Complementarily, the core can be configured to perform decryption by
asserting the signal $\portKHInverse$ during the first transaction. When a key
configuration is ongoing, the signal $\portKHBusy$ is asserted. 

When configured to compute decryption, the module stores a sharing of the last
round key corresponding the key provided. To do so, the key storage unit
controls the $\topModAES$ module in order to perform a dummy encryption upon
the reception of a new key. In particular, the signal $\portKHLastKeyReq$ is
used to start a dummy encryption with module $\topModAES$ during witch the
logic unrelated to the key schedule algorithm is disabled (using signal
$\portAESKSchedOnly$). At the end of the dummy encryption, the signal
$\portAESLastKeyColPreValid$ is asserted and the value of the (shared) last
round key is fetched back using the bus $\portAESLastKeyCol$, by serially
obtaining the shared value of a single column per cycle. In such a case, the
signal $\portKHBusy$ is asserted until the key material of the last round key
have not been recovered by the key storage unit. 

During each standard execution (i.e., execution not related to a key
configuration), the key shares hold by the module $\topModKHOLD$ are refreshed
on-the-fly. This is made possible due to the fact that some part of the fresh
randomness provided through the bus $\portAESRnd$ to the module $\topModAES$ is
not used by the latter during specific cycles of the execution of a round
function. Such cycles are advertised to the key storage unit by asserting the signal
$\portAESRndRfValid$. It results that the key refresh is performed with no latency penalty.  

\paragraph{Arbitrer}
The module $\topModArbitrer$ is used in order to implement the interlocking
logic internal to the core.  In particular, it takes as input the control
signals of the three input streams (i.e., $\svrsKeyValid$, $\svrsKeyReady$,
$\svrsInValid$, $\svrsInReady$, $\svrsSeedValid$ and $\svrsSeedReady$) and
generate the internal control signal that drive the modules $\topModAES$,
$\topModKHOLD$ and $\topModPRNG$ according to the precedence rules detailled in
Section~\ref{section:core_usage}. 

\paragraph{Share shuffling}
The modules $\texttt{shares2shbus}$ and $\texttt{shbus2shares}$ are simple wire
shuffling that ``transpose'' the encoding of the shared data.
More precisely, the encoding of a sharing inside $\topModAES$
is $\texttt{shares\_data\_inner}\left[ ni+j\right] = b_j^i$ unlike the more
intuitive external representation $\texttt{shares\_data}\left[ ni+j\right] =
b_i^j$ described in Section~\ref{sec:share_encoding}.
This internal representation is more convenient for the implementation, as it
makes it easier to describe the extraction of masked bits from a masked bus
using Verilog operators.

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{
        \begin{tikzpicture}
            \input{figures/tikz_fig_smaesh_top}
        \end{tikzpicture}
    }
    \caption{Global architecture of the module \topName.}
    \label{fig:smaesh_top_module}
\end{figure}

\subsection{Masked AES Core Architecture} 
\label{section:masked_aes_core_arhcitecture}

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{
        \begin{tikzpicture}
            \input{figures/tikz_aes_glob_arch}
        \end{tikzpicture}
    }
    \caption{Datapath architecture of the module \topModAES. Wires not in bold are $32d$ bits wide (apart from muxes control signals).}
    \label{fig:aes_glob_arch}
\end{figure}

The module $\topModAES$ is based on the 32-bit masked AES implementation
presented in~\cite{DBLP:conf/cosade/MominCS22}. As shown in
Figure~\ref{fig:aes_glob_arch}, the module is organized around two datapath
blocks performing the operations dedicated to the round computation (denoted
\modAESdpState) and the key scheduling (denoted $\modAESdpKey$). The module
$\modAESsbox$ is shared between the two datapath blocks and implements the
$\SB$ layer for 4 masked bytes. In particular, it is composed of 4~parallel
instances of the masked S-boxes implementation presented
in~\cite{DBLP:journals/tches/CassiersGMMN24} that relies on the representation
presented in~\cite{DBLP:conf/ches/Canright05}.  Each instance implements both
the forward and inverse operation, chosen at run-time using a dedicated control
signal. More into the details, the S-box is composed of three different layers:
a non-linear layer surrounded by a linear layer at input and output. While the
linear layers (both at the input and output) are different for forward and
inverse operation, the (costly) non-linear layer remains the same and can be
shared when performing operations in both ways.  Executing either the forward
or inverse operation is done in practice by using muxes at the input/output
linear layers that forwards the data accordingly to the chosen mode of execution. 

The S-boxes have been generated using COMPRESS, and are thus optimized for a
given amount of shares. The amount of shares implemented in a practical
integration can be modified at synthesis time by changing the generic $d$ at
the top level. However, a mismatch between the amount of shares instantiated
and the amount of shares specified during the S-box generation with COMPRESS
may lead to suboptimal performance (i.e., area). In this
document, we report the results for four different protection levels, namely
$d\in[2,3,4,5]$. If another amount of shares is required, it is advised to
generate an optimal S-box implementation using COMPRESS\footnote{Please refer
    to
    \href{https://github.com/cassiersg/compress_artifact}{https://github.com/cassiersg/compress\_artifact}
for more info}.  Overall, a single S-box instance is organized as a pipeline of 4 stages that
requires 36 random bits (resp. 96, 192 and 300) per execution considering $d=2$
(resp. 3, 4 and 5). The bus $\portAESRnd$ is used to provide the fresh
randomness to the 4~S-boxes instances (randomness is not used anywhere else in
$\topModAES$). 

\subsection{Architecture of the $\modAESdpState$ module}
\label{sec:architecture}

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{
        \begin{tikzpicture}
            \input{figures/tikz_dpState}
        \end{tikzpicture}
    }
    \caption{Global architecture of the \modAESdpState module. The value held by the DFF at index $i$ is depicted by the signal $\dpStateDFF{i}$ in the HDL.}
    \label{fig:aes_dpState}
\end{figure}

Figure~\ref{fig:aes_dpState} shows the detailed architecture of the
module $\modAESdpState$. It is organized as a shift register where each
register unit holds a masked state byte (the numbers on the figure
indicate the byte index in the unmasked state).
The module operates on 32-bit parts of the state and is also implementing the
logic that computes the $\AK$, $\SR$ and $\MC$ layers, both for the forward and inverse operation.
In particular, these are implemented in purely combinational logic.   

\paragraph{Encryption} When performing an encryption, addition gadgets (i.e., XORs) are used to
perform the key addition with key bytes coming from the round key (denoted
$\AESdpStateFromKey$). The module $\dpStateModMC$ computes the result of the
$\MC$ operation for a masked column (i.e., 4~masked bytes). The $\SR$ layer is
free, being implemented as a specific routing at the input of the $\SB$ layer.
In particular, the ordering of the bytes routed to the S-boxes (denoted
$\AESdpStateToSB$) is selected such that the rotations over the rows are
applied. Dedicated MUXes (controlled by $\dpStateCtrlRouteMC$) are used in
order to bypass the $\MC$ logic block when executing the last round.  Other
MUXes (controlled by $\dpStateCtrlRouteLoop$) are used during the last key
addition in order to bypass the $\SR$, $\SB$ and $\MC$ layers.  When a new
execution starts, the masked plaintext bytes are loaded in the register through
the MUXes controlled by $\dpStateCtrlRouteIn$.  Then, the $\AK$ and $\SR$
layers are executed by propagating the data across the pipeline to the S-boxes
(by selecting the data $\dpStateToSBForward$ with the MUX driving the signal
$\AESdpStateToSB$).  The $\MC$ operation is performed when the result of the
$\SB$ layer is coming back to the core by asserting the signal
$\dpStateCtrlRouteMC$. 

\paragraph{Decryption} When performing a decryption, addition gadget are used to add the key bytes
coming from the round key (denoted
$\AESdpStateFromKeyInverse$). These are located in order to add the key
material with the first column of the state (i.e., bytes indexes in [0,1,2,3]).
The addition gadget located at the byte index 0 is shared between the
encryption and decryption process. The additions outcomes are forwarded to the
module $\dpStateModMCInv$ that implements the inverse $\MC$ operation for a
masked column. A dedicated mux (controlled by $\dpStateCtrlBypassMCInverse$)
allows bypassing the latter, as required when computing the inversion of the
last round. The data are then forward to the S-boxes (by selecting the data
$\dpStateToSBReverse$) in order to compute the inverse $\SB$ layer.  The
inverse $\SR$ layer is implemented by dedicated MUXes that allows to insert the
bytes coming back from the S-boxes to the proper location (i.e., byte indexes in
[12,1,6,11]). Similarly to the key addition, the MUX inserting data at the byte
index 12 is shared between the encryption and the decryption.  

\subsection{Architecture of the $\modAESdpKey$ module}
\label{section:module_dpkey}
\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{
        \begin{tikzpicture}
            \input{figures/tikz_dpKey}
        \end{tikzpicture}
    }
    \caption{Global architecture of the module $\modAESdpKey$. The value held by the DFF at index $i$ is depicted by the signal $\dpKeyDFF{i}$ in the HDL.}
    \label{fig:aes_dpKey}
\end{figure}

The module $\modAESdpKey$ is shown in Figure~\ref{fig:aes_dpKey}. It is
organized as a shift register where each register unit holds a masked byte of
the key. The module is split in 4~independent parts, each taking care of the
key scheduling operation on a single row. The sharing of the key is routed from
the input with the control signal $\dpKeyCtrlInit$. Depending on the key size
configured, some part of the bus $\AESdpKeyKey$ may contain 'dont care' values
and some registers are turned off. In particular, the bytes indexes from 16 to
31 are not used in the 128-bit key version (i.e., registers are disabled) and
the bytes indexes from 24 to 31 are initially considered as holding 'dont care'
value in the 192-bit key version.

Two relevant bytes ordering are depicted on the Figure and both refers to the
byte index in the unmasked key. First, the numbers on the top depict the
register location and correspond to the byte ordering at the beginning of a
round when the key addition occurs (the byte ordering is relative to the round
execution flow). Second, the bottom number (between parentheses) depict the
byte ordering when a fresh execution starts, at the last cycle of a round or
when the $\SB$ layer results of the key scheduling are fetched back from the
S-boxes, as detailed next. In practice, the second ordering corresponds to the
first one with a rotation of 1 column to the left when considering the first 4
columns only. The structure composed of the registers driven by MUXes that are
controlled with the signal $\dpKeyCtrlRstBuffer$ as well ass the XORs they are
driving are not used during encryptions (i.e., $\dpKeyCtrlRstBuffer$ is constantly set to
'1'). 

\paragraph{AES-128 Encryption} When computing a 128-bit encryption, the key scheduling starts by sending the
last column of the key (i.e., byte indexes 12, 13, 14 and 15, but that are
located in positions 0,1,2 and 3) to the S-boxes.  To do so, the signals
$\dpKeyCtrlReverseDefaut$ and $\dpKeyCtrlColSevenToSB$ are set to '0' in order
to let the data pass through the MUXes up to the output of the core.  The
$\texttt{RotWord}$ operation is performed by using an appropriate routing of
the signal $\AESdpKeyToSB$ that sends the key bytes to the S-boxes.  Once
computed, the result of the $\SB$ layer is routed back to the core through the
MUX controlled by the signal $\dpKeyCtrlRouteFromSB$, by setting to '0' the signal $\dpKeyCtrlDisableRot$.  At the same time, the
round constant is applied and the first column (i.e., byte indexes 0,1,2 and 3)
of the new round key is computed by adding the first column of the key (thus located in positions 4,5,6 and 7) to the column coming back from
the S-boxes. The remaining three columns (i.e., byte indexes [4,5,6,7],
[8,9,10,11] and [12,13,14,15]) are then updated sequentially by XORing each
byte with the value of the last byte updated in the same row. 
The signal $\dpKeyCtrlLoop$ is used to make the key shares loop across the key
pipeline.  This is required to keep the key material after the $\AK$ operations
while the $\SB$ results of the key scheduling is still under computation. 

\paragraph{AES256 Encryption}The architecture required for the 256-bit encryption is built upon the 128-bit
one, and presents some specificities detailed next. The signal
$\dpKeyCtrlColSevenToSB$ is asserted at the very first cycle of an execution in
order to send the seventh column of the key (i.e., bytes indexes 28,29,30 and
31) instead of the fourth one, accordingly with the 256-bit version
specifications. It is de-asserted for the remaining of the execution. When new
round key material are computed, the registers at positions 16 to 31 are
enabled in order to store these. In the same time, the data hold in these
registers are propagated through the pipeline by asserting the signal
$\dpKeyCtrlFBFromHigh$. The MUX controlled by the signal $\dpKeyCtrlDisableRot$
allows bypassing the addition of the round constant together with
$\texttt{RotWord}$ operation, as required by one round out of two with the
256-bit version. 

\paragraph{AES-128/256 Decryption} Naively, the inversion of the key scheduling can be implemented by performing
the inverse operation of the key schedule algorithm, in reverse order. That is,
considering that a round key is composed of 4 columns of 32-bit, the three last
columns of an update key can be computed by sequentially XORing the last three
columns of the current key.  For the first column, one must additionnally XOR
the result of the $\SB$ operation applied to the last column of the updated
key, obtained as described above by XORing the two last columns of the current
key (that is, the two columns composed of the key bytes at indexes
[12,13,14,15] and [8,9,10,11]). As a reminder, the 256-bit version does not
require the \texttt{RotWord} operation and the addition of the round constant
at every round, which can be disabled by properly driving the signal
$\dpKeyCtrlDisableRot$. Implementing this exact computational flow would at
least require to route the data through the pipeline in the opposite direction
to what is already implemented for the encryption, leading to significant area
overhead (e.g., at least $128d$ MUXes and logic replication). Instead, the core
stick the data propagation flow of the encryption and implements the inverse
key schedule as detailed next. First, the last column of the updated key is
computed by XORing the last two columns. In parallel, the latter is routed to
the S-boxes by asserting the signal $\dpKeyCtrlReverseDefaut$.  Next, the key
update is similar to what is done during an encryption. That is, the first
column of the updated key is computed by XORing the first column of the current
key (located at the positions 4,5,6 and 7) with the material coming back from
the S-boxes. The following three columns are computed sequentially by XORing the
freshly updated column (located at positions 0,1,2 and 3) with the column of
the current key (located at positions 4,5,6 and 7). Aditionally, the signal
$\dpKeyCtrlRstBuffer$ is asserted for 4 consecutive cycles in order to
accumulate the value coming back from the S-boxes with the sequential freshly
updated key columns.  The latter mechanism is required for functionality
purpose of the algorithm. Similarly to hte encryption process, the freshly
updated key material are propagated through the pipeline, either to the
locations [12,13,14,15] for the 128-bit version, either to the locations
[28,29,30,31] for the 256-bits version. 

\paragraph{AES-192}
The 192-bit version of the algorithm takes advantage of the existing
structure and is implemented without any additional logic apart from specific
control.  

\subsection{Internal operations}

\paragraph{Overview}
For the three version of the algorithm, the round computations (i.e.,
computation occurring inside the module $\modAESdpState$) are performed in
parallel to the key schedule (i.e., computations occurring inside the module
$\modAESdpKey$).

As the structure of the 128-bit and 256-bit versions are reasonably similar,
they benefit from the same performance in terms of latency, whether for
encryption or decryption.  The latter is equal to $1+\Nr\cdot(8)+4$ cycles,
where $\Nr = 10$ and $\Nr= 14$ for the 128-bit and 256-bit versions
respectively. The first cycle (i.e., the '1' in the equation) correspond to the
cycle where the first key material are sent to the S-boxes in order to start the
key update mechanism. Then, the $\Nr$ round are executed sequentially, each of
them requiring 8 cycles to proceed.  Finally, the final key addition is
performed in 4 cycles. 

Due to the fact that there is less structural similarity between the rounds
computations (which consist in applying the same operation on 128-bit states)
and the evolution of the key (which consist in applying the same operation on
192-bit parts), the implementation requiring no additional logic described in
Section~\ref{section:module_dpkey} comes at the cost of a significant latency
overhead. The latter is directly caused by the complexity of computing the key
scheduling part without modifying the existing module. The flow followed by the
round computations taking place inside the module $\modAESdpState$ is not
modified, with the difference that the registers are stalled at the end of a
round computation to allow the next key computation to be completed before
starting the next round.  Its implementation consists of a complex control of
the existing pipeline, making it possible to implement a step that updates 18
successive key columns in 49 cycles during an encryption (resp. 29 during a
decryption) and that is repeated 4 times to achieve a complete update.
Similarly to the other version, the first cycle of an execution is not related
to the round computation, but is rather used in the context of the 192-bit
version to ensure a proper ordering of the key bytes before starting a round
computation. Also, the final key addition is performed in 4 additional cycles. 

\paragraph{Detailed AES-128 Encryption flow}
Let us first introduce notations for the intermediate states in the AES algorithm with
pseudo-code in Figure~\ref{fig:code_round} and Figure~\ref{fig:code_key}.
Each variable denotes a state or subkey byte at a given step of the algorithm.
In particular, the plaintext (resp. key, ciphertext) byte at index $0\leq i<16$
is denoted \pP{i} (resp. $\pK{i}$, $\pCt{i}$), and the value $\pS{i}{r}$ (resp.
$\pRK{i}{r}$) denotes the byte at index $i$ of the state (resp. round key)
starting the $r$-th round.
When no index is given, the full 128-bit state is considered instead.

\begin{figure}
    \begin{lstlisting}[frame=single]
    %%% First key addition
    for $0\leq i <16$ do
        $\pS{i}{0} = \pP{i} \oplus \pK{i}$;
    done
    
    %%% Perform the rounds
    for $0\leq r < 9$ do 
        % Operation for a single round
        $\pSR{}{r} = \SR(\pS{}{r})$;
        $\pSB{}{r} = \SB(\pSR{}{r})$;
        $\pMC{}{r} = \MC(\pSB{}{r})$;
        $\pAK{}{r} = \AK(\pMC{}{r},\pRK{}{r})$;
        $\pS{}{r+1} = \pAK{}{r}$;
    done
    
    %%% Last round
    $\pSR{}{9}=\SR(\pS{}{9})$;
    $\pSB{}{9}=\SB(\pSR{}{9})$;
    $\pAK{}{9}=\AK(\pSB{}{9})$;
    $\pCt{} = \pAK{}{9}$;
    \end{lstlisting}
    \caption{Pseudo-code of the AES encryption.}
    \label{fig:code_round}
\end{figure}


\begin{figure}
    \begin{lstlisting}[frame=single]
    %%% Key evolution for each round key 
    for $0\leq r < 10$ do
        % Fetch value on which operate
        if $r==0$ then
            $t^r = \pK{}$; 
        else 
            $t^r = \pRK{}{r-1}$;
        end

        % Perform the last column rotation
        $[\pR{0}{r},\pR{1}{r},\pR{2}{r},\pR{3}{r}] = [t_{13}^{r},t_{14}^{r},t_{15}^{r},t_{12}^{r}]$; 

        % Perform SubWord on the rotated column
        $[\pRSB{0}{r},\pRSB{1}{r},\pRSB{2}{r},\pRSB{3}{r}] = [\SW{\pR{0}{r}},\SW{\pR{1}{r}},\SW{\pR{2}{r}},\SW{\pR{3}{r}}]$

        % Compute the first column of the next round key
        $\pRK{0}{r} = \pRSB{0}{r} \oplus t_{0}^{r} \oplus \RCON{r}$;
        $\pRK{1}{r} = \pRSB{1}{r} \oplus t_{1}^{r}$;
        $\pRK{2}{r} = \pRSB{2}{r} \oplus t_{2}^{r}$;
        $\pRK{3}{r} = \pRSB{3}{r} \oplus t_{3}^{r}$;

        % Generate the three remaining columns
        for $1\leq i <4$ do
            for $0\leq j <4$ do
                $\pRK{4i+j}{r} = \pRK{4(i-1)+j}{r} \oplus t_{4i+j}^{r}$;
            done
        done
    done
    \end{lstlisting}
    \caption{Pseudo-code for the AES-128 key evolution.}
    \label{fig:code_key}
\end{figure}

\begin{figure}
    \centering
    \input{figures/tikz_time_pipe_sbox}
    \caption{Data going into / coming from the S-boxes during an encryption round of AES-128.}
    \label{fig:pipe_sbox}
\end{figure}


\begin{figure}
    \centering
    \input{figures/tikz_time_pipe_dpkey}
    \caption{Data going into / coming from the key scheduling datapath during an encryption round of AES-128.}
    \label{fig:pipe_dpkey}
\end{figure}

\begin{figure}
    \centering
    \input{figures/tikz_time_pipe_dpstate}
    \caption{Data going into / coming from the round function datapath during an encryption round of AES-128.}
    \label{fig:pipe_dpstate}
\end{figure}


\begin{figure}
    \centering
    \input{figures/tikz_time_first_round} 
    \caption{Data routing when a new encryption of AES-128 starts.}
    \label{fig:time_first_round}
\end{figure}

Using these notations, Figures~\ref{fig:pipe_sbox}, \ref{fig:pipe_dpkey}
and~\ref{fig:pipe_dpstate} describe the evolution of the AES states stored in
the architecture over the computation of one round.
Next, Figures~\ref{fig:time_first_round}, \ref{fig:time_regime}
and~\ref{fig:time_last_round} depict the control signals that drive the
datapath for the first round, middle rounds, and last round. Unspecified control signal are supposed to be tied to '0'.
In particular, for the first round (Figure~\ref{fig:time_first_round}), the
data is fetched by the module when the signal $\portAESInValid$ is asserted if
the core is not busy, there is no ciphertext stored in the core and randomness
is available.
At the next clock cycle, the
internal FSM counters $\timeCnrRound$ and $\timeCnrCycle$ are reset and the
execution begins. The round function and the key scheduling algorithm are
executed in parallel by interleaving the S-boxes usage appropriately. In
particular, the first cycle of the execution is used to start the key
scheduling algorithm by asserting $\AESsboxFeedKey$ and $\AESsboxValidIn$.
During this cycle, the module $\modAESdpKey$ is enabled and the
$\dpKeyCtrlLoop$ (rotating then the columns), while the module $\modAESdpState$
is disabled.
\begin{figure}
    \centering
    \input{figures/tikz_time_regime} 
    \caption{In regime data routing during an encryption of AES-128.}
    \label{fig:time_regime}
\end{figure}

Then, the core enters into a nominal regime that computes a round in 8~cycles,
as depicted in Figure~\ref{fig:time_regime}.  A typical round starts with
4~clock cycles during which data is read from the state registers, XORed with
the subkey and fed to the S-boxes, which performs the $\AK$, $\SR$ and $\SB$
layers for the full state (one column per cycle).  During these cycles,
$\AESsboxValidIn$ is asserted and data (state and subkey) loops over the shift
registers. An exception occurs at the fourth cycle (i.e., when
$\timeCnrCycle=3$): at this cycle, the S-boxes output the column of the new
subkey value, which is processed by deasserting $\dpKeyCtrlLoop$.  Next, during
the last 4~cycles of a round, the S-boxes output the 4~columns of the state, on
which the $\MC$ layer is directly applied, and the result is stored in the
state registers. At the same time, the subkey update is finalized, such that a
new subkey is ready at the last cycle of a round (i.e., $\timeCnrCycle=7$).
During this last cycle, the next key schedule round is started, and a new state
round starts at the following cycle.

\begin{figure}
    \centering
    \input{figures/tikz_time_last_round} 
    \caption{Data routing during last rounds of an encryption of AES-128.}
    \label{fig:time_last_round}
\end{figure}

Finally, the last round is very similar to the regime mode except that the
module $\dpStateModMC$ is bypassed. In particular, the signal
$\dpStateCtrlRouteMC$ is de-asserted and the shift registers are configured to
make the data loop. No new key scheduling round is started during this last
cycle.
At the end of the last round, once the ciphertext has been fetched from the
output, a new encryption starts immediately (if $\portAESInValid$ is asserted),
or the state register is cleared by asserting the control signal
$\dpStateCtrlRouteIn$.
This ensures that the core is completely clear of any key- or
plaintext-dependent data.


As a complementary note, the flow occurring for the decryption can be quite
easily inferred from the timing figures provided as well at the architecture
details described in Section~\ref{sec:architecture} and
Section~\ref{section:module_dpkey}. Besides, the
Figure~\ref{fig:pipe_sbox_decryption} and
Figure~\ref{fig:pipe_dpstate_decryption} are provided as the complement to
Figure~\ref{fig:pipe_sbox} and Figure~\ref{fig:pipe_dpstate}.  Due to the
similarities between the 128-bit and the 256-bit version, the same comment
holds for the 256-bit version. The 192-bit version is not detailed here. 

\begin{figure}
    \centering
    \input{figures/tikz_time_pipe_sbox_decryption}
    \caption{Data going into / coming from the S-boxes during a decryption round of AES-128.}
    \label{fig:pipe_sbox_decryption}
\end{figure}

\begin{figure}
    \centering
    \input{figures/tikz_time_pipe_dpstate_decryption}
    \caption{Data going into / coming from the round function datapath during a decryption round of AES-128.}
    \label{fig:pipe_dpstate_decryption}
\end{figure}


\subsection{Randomness Generation} 

%CiC-1-2-4

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{
        \begin{tikzpicture}
            \input{figures/tikz_prng}
        \end{tikzpicture}
    }
    \caption{Datapath Architecture of a unrolled Trivium module}
    \label{fig:prng}
\end{figure}


\label{subsection:PRNG}

The module $\topModPRNG$ is a PRNG generating all the pseudo-random bits
required by the S-boxes in a single clock cycle, denoted next \NRNDBITS.
Following the recommendation from~\cite{CiC-1-2-4}, it is based on one or
multiple instances of the Trivium stream
cipher~\cite{DBLP:series/lncs/CanniereP08} from which the key stream is used as
the PRNG output. As shown in Figure~\ref{fig:prng}, a Trivium instance is
implemented using a 288-bit state register and $\UNROLL$ cascaded combinational
layers that each implement one state update step and produce one keystream bit.
Moreover, the state register is either taken from a re-seed value (to initiate a
re-seed), or from the output of the final update step (during normal operation).
At the output, the keystream is stored in a register to avoid the propagation
of glitches that could reduce the security of the masked circuit.

The use of multiple Trivium instances allows us to adjust the area-latency
trade-off: with more Trivium instances, $\UNROLL$ can be reduced, leading to a
lower combinational logic depth.  The top-level $\MAXUNROLL$ parameter is used
for this purpose: the number of instances is $\NTRIVIUMS = \lceil \NRNDBITS /
\MAXUNROLL \rceil$, and $\UNROLL = \lceil \NRNDBITS / \NTRIVIUMS \rceil$, which
ensures that $\UNROLL \le \MAXUNROLL$.

The re-seeding follows the initialization of Trivium. Concretely, the state is
first set to
$\texttt{1}^3|\texttt{0}^{112}|\texttt{IV}|\texttt{0}^{13}|\texttt{KEY}$, where
the \texttt{KEY} is set to the 80-bit externally provided seed (it is
the same for all Trivium instances), while the \texttt{IV} is a constant, which
is distinct for each Trivium instance.  Then, the update function is applied at
least $4\cdot 288$ times, i.e., the PRNG is executed while feeding back its
state for $4\cdot 288 / \UNROLL$ cycles.  During the re-seed, the signal
$\portPrngBusy$ is asserted and $\portPrngOutValid$ is not. Once finished, the
signal $\portPrngOutValid$ is asserted.  After a reset, the core requires will
not output valid data (i.e., $\portPrngOutValid$ will stay de-asserted) until
the completion of a re-seed.
  
\section{Core Performances}


\begin{table}
    \centering
    \setlength{\tabcolsep}{1ex}
    \begin{threeparttable}
        \sisetup{
            table-alignment-mode = format,
            table-number-alignment = center,
            }
        \begin{tabular}{lcS[table-alignment-mode=format,table-format=3.1,round-mode=places,round-precision=1]} 
            \toprule
            {Design} & {\makecell{Shares}} & {Area (kGE)} \\ \midrule
            \midrule
            \multirow{6}{*}{SMAesH} &    &         \\
                                         & 2  & 29.429  \\
                                         & 3  & 52.546   \\
                                         & 4  & 84.249   \\
                                         & 5  & 119.981  \\
                                         &    &          \\
            \bottomrule
        \end{tabular}
        \caption{NanGate45 PDK synthesis results}
        \label{table:synth}
    \end{threeparttable}
\end{table}

\begin{table}
    \centering
    \setlength{\tabcolsep}{1ex}
    \begin{threeparttable}
        \sisetup{
            table-alignment-mode = format,
            table-number-alignment = center,
            }
        \begin{tabular}{ccc} %[table-alignment-mode=format,table-format=3.1,round-mode=places,round-precision=1]
            \toprule
            {Version} & Algorithm & {Latency (cycles)} \\ \midrule
            \midrule
            \multirow{2}{*}{128} & Enc & 86 \\
                                 & Dec & 86 \\\addlinespace[0.8ex]
            \multirow{2}{*}{192} & Enc & 201 \\
                                 & Dec & 121 \\\addlinespace[0.8ex]
            \multirow{2}{*}{256} & Enc & 118 \\
                                 & Dec & 118 \\
            \bottomrule
        \end{tabular}
        \caption{Feature performances metric}
        \label{table:perfos}
    \end{threeparttable}
\end{table}

Following the architecture described section~\ref{sec:architecture}, the
following tables contain implementation results. Table~\ref{table:synth}
contains post-synthesis implementation metrics obtained with Yosys for the
NanGate45 Open Cell Library, and Table~\ref{table:perfos} contains feature
performance metric.

\section{Core Verification}
\label{section:verif}
\subsection{Functional tests}
The functional tests performed are currently split in three levels, detailed next. 

\paragraph{KAT verification}The Known-Answer Tests of the NIST
``Advanced Encryption Standard Algorithm Validation List'' are verified
\footnote{https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/block-ciphers}.
In particular, all the testvectors contained in the files
\texttt{ECBGFSbox*.rsp}, \texttt{ECBKeySbox*.rsp}, \texttt{ECBVarKey128.rsp}
and \texttt{ECBVarTxt*.rsp} are tested at the RTL level, both in encryption and
decryption for the three variants of the algorithm.  

\paragraph{Key storage unit}The key storage unit is tested in order to
ensure that the value of the stored key remains the same across multiple
sequential executions. Additionally, a basic verification is performed to check
that the shares values are refreshed between two consecutive execution. 

\paragraph{Fuzzing Strategy}A basic fuzzing strategy is used in order to compare the results
obtained between the executions of the core and a reference model implemented in
Python under the cocotb framework~\footnote{https://www.cocotb.org/}.
In particular, the verification is organized around different processes.  

The first task is the generation of randomized input patterns. More into the
details, the three inputs streams are generated independently in a randomized
manner: the core idea of the randomization is that the validity control signal
of the SRVS protocol are asserted with a delay (in term of clock cycles) drawn
randomly between each assertion. Once asserted, the stream generator respects
the sticky property by ensuring that the signal remains valid until the
completion of a transaction. The delay's range has been chosen trying to
achieve the same proportion of seed configuration, key configuration or
execution starts during the cycles simulated. 

The main process is the simulation of the design based on the input patterns
generated. This is achieved through the cocotb framework by directly driving
the ports of the design under tests. 

In parallel, the inputs streams are monitored by a SRVS protocol interpreter.
Due to the fact that a single configuration can occur at a time following the
core usage presented in Section~\ref{section:core_usage}, the latter can build a
sequence of commands that can be used at a higher abstraction level (i.e., configuring a new
seed, configuring a new key or starting a new execution). These are
forwarded to a reference model that simulates the expected evolution of the
core's (unmasked) internal states resulting from the input patterns applied. When
an execution finishes, the expected output value if forwarded to a FIFO in
order to validate in-order the data outputted by the design under test.

At the output interface of the core, a randomized digester is used to handle the
output SVRS protocol, while simulating back-pressure. In particular, a strategy
similar to the randomized delay one used for stream generation is used in order
to assert the ready signal of the output stream. 

Finally, the core's validation is in practice performed by monitoring the
the output stream of the core. In particular, each time a transaction occurs,
the (masked) output is recombined, and the result is compared to the data
located at the output of the reference FIFO. An error is raised if a single
mismatch occurs at this step. The overall verification consists in running this
framework for an arbitrary amount of clock cycles.  The verification is
considered as successful if no error occurred at the end of the simulation. 

\subsection{Side-channel security}
This core has been formally verified for security in the glitch+transition
robust probing model using the \texttt{MATCHI}%
tool~\cite{DBLP:journals/tc/CassiersGLS21,DBLP:journals/tches/CassiersS21}\footnote{\url{https://github.com/cassiersg/matchi}}.
The scripts for this verification are provided along with the implementation.

A preliminary physical analysis of the core can be found at
\url{https://www.simple-crypto.org/activities/smaesh/}.  Additionnally, the
core (v1.0, limited to AES-128 encryption) went through a public empirical
evaluation in the context of the CHES23 challenge. The public evaluation
is still open and more details are available at
\url{https://smaesh-challenge.simple-crypto.org/}.  The adversary's goal is to
recover the value of the key from the power traces collected for FPGAs
implementation of the core. Note that this evaluation is device-specific.

\section{Copyright}

This document is Copyright (c) SIMPLE-Crypto contributors\footnote{see \url{https://github.com/simple-crypto/SMAesH}.}.

Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.3 or any later version
published by the Free Software Foundation; with no Invariant Sections, no
Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is available with the sources of the implementation and
at \url{https://www.gnu.org/licenses/fdl-1.3.txt}.

\bibliographystyle{alpha}
\bibliography{refs}

\end{document}
