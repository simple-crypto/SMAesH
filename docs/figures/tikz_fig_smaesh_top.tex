
% Global config
\def\fsIO{\Large}
\def\fontS{\Large}
\def\sizeB{0.9mm}
\def\sizeW{0.4mm}
\def\portOff{0.5}


%\debugtrue

\def\Rad{5pt}
\def\dotRad{0.10}

\tikzset{
dot/.style = {circle, fill, minimum size=#1,
              inner sep=0pt, outer sep=0pt},
dot/.default = 6pt % size of the circle diameter 
}

% W internal port macro with annotation
% #1 style
% #2 id
% #3 loc
% #4 text
\def\yshw{3mm}
\def\xshw{2mm}
\newcommand{\portW}[4][]{
    \node [dot=\Rad] (ncirc) at (#3) {};
    \node [#1,anchor=west,yshift=\yshw] at (#3) {#4};
    \coordinate (#2) at (ncirc.west);
    \coordinate (#2/m) at (ncirc.east);
}
% E internal port macro with annotation
% #1 style
% #2 id
% #3 loc
% #4 text
\newcommand{\portE}[4][]{
    \node [dot=\Rad] (ncirc) at (#3) {};
    \node [#1,anchor=east,yshift=\yshw] at (#3) {#4};
    \coordinate (#2) at (ncirc.east);
    \coordinate (#2/m) at (ncirc.west);
}
% S internal port macro with annotation
% #1 style
% #2 id
% #3 loc
% #4 text
\newcommand{\portS}[4][]{
    \node [dot=\Rad] (ncirc) at (#3) {};
    \node [#1,anchor=east,xshift=\yshw,rotate=270] at (#3) {#4};
    \coordinate (#2) at (ncirc.south);
    \coordinate (#2/m) at (ncirc.north);
}
%%%%%% TOP arrow
\def\awidth{0.4mm}
\def\xarr{2cm}
% W arrow port macro
% #1 port connected
\newcommand{\arrW}[2][]{
    \draw [#1,line width = \awidth] ($(#2)+(-\xarr,0)$) -- (#2);
}
% E arrow port macro
% #1 port connected
\newcommand{\arrE}[2][]{
    \draw [#1,line width = \awidth] (#2) -- ++(\xarr,0);
}

% AES bloc
% #1: id
% #2: pos TR
\newcommand{\blocAES}[2]{
    %% Draw the rectangle
    \rectangleC[line width = 0.6mm]{box}{#2}{($ #2 + (-10,-20)$)}{19}{19}{1}{3};
    \draw node[rectangle,draw,line width=0.6mm,anchor=north west] at (box/TL) {\fontS \topModAES};
    %% Draw the IO ports
    % Draw W
    \portW{#1/in_last_key_col}{box/W2}{\fontS \portAESLastKeyCol}
    \portW{#1/in_last_key_col_pre_valid}{box/W3}{\fontS \portAESLastKeyColPreValid}
    \portW{#1/rnd_rfrsh_valid}{box/W4}{\fontS \portAESRndRfValid}
    \portW{#1/mode_192}{box/W5}{\fontS \portAESModeI}
    \portW{#1/mode_256}{box/W6}{\fontS \portAESModeII}
    \portW{#1/inverse}{box/W7}{\fontS \portAESInverse}
    \portW{#1/key_sched_only}{box/W9}{\fontS \portAESKSchedOnly}
    \portW{#1/in_key}{box/W10}{\fontS \portAESInKey}

    \portW{#1/in_valid}{box/W16}{\fontS \portAESInValid}
    \portW{#1/in_ready}{box/W17}{\fontS \portAESInReady}
    \portW{#1/busy}{box/W18}{\fontS \portAESbusy}
    \portW{#1/in_data}{box/W19}{\fontS \portAESInData}
    % Draw E
    \portE{#1/out_valid}{box/E2}{\fontS \portAESOutValid}
    \portE{#1/out_ready}{box/E3}{\fontS \portAESOutReady}
    \portE{#1/out_data}{box/E4}{\fontS \portAESOutData}
    % Draw S
    \portS{#1/rnd_ready}{box/S2}{\fontS \portAESRndReady}
    \portS{#1/rnd}{box/S3}{\fontS \portAESRnd}
    % Generate coordinate
    \coordinate (#1/center) at #2;
}

% PRNG bloc
% #1: id
% #2: pos TR
\newcommand{\blocPRNG}[2]{
    %% Draw the rectangle
    \rectangleC[line width = 0.6mm]{box}{#2}{($ #2 + (-7,-5)$)}{4}{4}{1}{1};
    \draw node[rectangle,draw,line width=0.6mm,anchor=north west] at (box/TL) {\fontS \topModPRNG};
    %% Internal coordinate
    \coordinate (#1/TR) at (box/TR);
    %% Draw the IO ports
    % Draw W 
    \portW{#1/start_reseed}{box/W2}{\fontS \portPrngStartReseed}
    \portW{#1/busy}{box/W3}{\fontS \portPrngBusy}
    \portW{#1/in_seed}{box/W4}{\fontS \portPrngSeed}
    % Draw E
    \portE{#1/out_valid}{box/E2}{\fontS \portPrngOutValid}
    \portE{#1/out_ready}{box/E3}{\fontS \portPrngOutReady}
    \portE{#1/out_rnd}{box/E4}{\fontS \portPrngOutRnd}
}


% Kunit bloc
% #1: id
% #2: pos TR
\newcommand{\blocKU}[2]{
    %% Draw the rectangle
    \rectangleC[line width = 0.6mm]{box}{#2}{($ #2 + (-11,-14)$)}{13}{13}{1}{5};
    \draw node[rectangle,draw,line width=0.6mm,anchor=north west] at (box/TL) {\fontS \topModKHOLD};
    %% Draw the IO ports
    % Draw E
    \portE{#1/out_last_key_col}{box/E2}{\fontS \portKHLastKeyCol}
    \portE{#1/out_last_key_col_pre_valid}{box/E3}{\fontS \portKHLastKeyColPreValid}
    \portE{#1/rnd_in_valid}{box/E4}{\fontS \portKHRndInValid}
    \portE{#1/mode_192}{box/E5}{\fontS \portKHModeI}
    \portE{#1/mode_256}{box/E6}{\fontS \portKHModeII}
    \portE{#1/mode_inverse}{box/E7}{\fontS \portKHInverse}
    \portE{#1/last_key_required}{box/E9}{\fontS \portKHLastKeyReq}
    \portE{#1/sh_data_out}{box/E10}{\fontS \portKHDataOut}
    \portE{#1/aes_busy}{box/E11}{\fontS \portKHAESbusy}
    % Draw S
    \portS{#1/rnd_rfrsh}{box/S1}{\fontS \portKHRndIn}
    % Draw W
    \portW{#1/data_in}{box/W2}{\fontS \portKHDataIn}
    \portW{#1/in_key_size_cfg}{box/W3}{\fontS \portKHSizeCfg}
    \portW{#1/in_mode_inverse}{box/W4}{\fontS \portKHInInverse}
    \portW{#1/start_fetch}{box/W7}{\fontS \portKHStartFetch}
    \portW{#1/data_in_ready}{box/W8}{\fontS \portKHDataInReady}
    \portW{#1/busy}{box/W9}{\fontS \portKHBusy}
    \portW{#1/data_in_valid}{box/W10}{\fontS \portKHDataInValid}
}


% Arbitrer bloc
% #1: id
% #2: pos TR
\newcommand{\blocArbitrer}[2]{
    %% Draw the rectangle
    \rectangleC[line width = 0.6mm]{box}{#2}{($ #2 + (-10,-15)$)}{14}{14}{1}{1};
    \draw node[rectangle,draw,line width=0.6mm,anchor=north west] at (box/TL) {\fontS \topModArbitrer};
    %% Draw the IO ports
    % Draw W
    \portW{#1/in_key_valid}{box/W3}{\fontS \svrsKeyValid}
    \portW{#1/in_key_ready}{box/W4}{\fontS \svrsKeyReady}
    \portW{#1/in_data_valid}{box/W8}{\fontS \svrsInValid}
    \portW{#1/in_data_ready}{box/W9}{\fontS \svrsInReady}
    \portW{#1/in_seed_valid}{box/W12}{\fontS \svrsSeedValid}
    \portW{#1/in_seed_ready}{box/W13}{\fontS \svrsSeedReady}
    % Draw E
    \portE{#1/KSU_start_fetch}{box/E2}{\fontS \portArbKSUStartFetch}
    \portE{#1/KSU_in_ready}{box/E3}{\fontS \portArbKSUReady}
    \portE{#1/KSU_busy}{box/E4}{\fontS \portArbKHBusy}
    \portE{#1/KSU_valid_in}{box/E5}{\fontS \portArbKSUValidIn}
    \portE{#1/KSU_lkey_req}{box/E6}{\fontS \portArbKSULastKeyReq}
    \portE{#1/aes_valid_in}{box/E8}{\fontS \portArbAESValidIn}
    \portE{#1/aes_in_ready}{box/E9}{\fontS \portArbAESReady}
    \portE{#1/aes_busy}{box/E10}{\fontS \portArbAESBusy}
    \portE{#1/prng_seeded}{box/E12}{\fontS \portArbPrngSeeded}
    \portE{#1/prng_start_reseed}{box/E13}{\fontS \portArbPrngStartReseed}
    \portE{#1/prng_busy}{box/E14}{\fontS \portArbPrngBusy}
}

%%% Draw AES block
\blocAES{aesModule}{(0,0)}

%%% Draw PRNG
\blocPRNG{prngMod}{(-18,-23)}

%%% Draw arbitrer
\blocArbitrer{arbitrer}{(-33,-5)}

%%% Draw Kholder
\blocKU{keyHolder}{(-15,0)}


%%% Draw the and at the input of the inverse signal to AES
\node[and port, anchor=in 1,xshift=1cm](and2_aes_inverse) at (keyHolder/mode_inverse){};
\node at (and2_aes_inverse.bin 2) [ocirc, left]{};

%%%%%%% DRAW INTERNAL connexion

%% KS <-> AES
\draw [line width=\sizeW, ->] (aesModule/in_last_key_col) -- (keyHolder/out_last_key_col);
\draw [line width=\sizeW, ->] (aesModule/in_last_key_col_pre_valid) -- (keyHolder/out_last_key_col_pre_valid);
\draw [line width=\sizeW, ->] (aesModule/rnd_rfrsh_valid) -- (keyHolder/rnd_in_valid);
\draw [line width=\sizeW, ->] (keyHolder/mode_192) -- (aesModule/mode_192);
\draw [line width=\sizeW, ->] (keyHolder/mode_256) -- (aesModule/mode_256);
\draw [line width=\sizeW, ->] (keyHolder/mode_inverse) -- (and2_aes_inverse.in 1);
\draw [line width=\sizeW, ->] (and2_aes_inverse.out) -- ++(0.5,0) |- (aesModule/inverse);
\draw [line width=\sizeW, ->] (keyHolder/last_key_required) --++(\portOff,0) |- (and2_aes_inverse.in 2);
\draw [line width=\sizeW, ->] (keyHolder/last_key_required) -- (aesModule/key_sched_only);
\draw [line width=\sizeW, ->] (keyHolder/sh_data_out) -- (aesModule/in_key);
\draw [line width=\sizeW, ->] (aesModule/busy) -- ++(-0.7,0) |- (keyHolder/aes_busy);

%% Output
\node[xshift=5cm, anchor=west,color=colorOUT] (svrs_out_data_valid) at (aesModule/out_valid) {$\svrsOutValid$};
\path let \p1=(svrs_out_data_valid.west),\p2=(aesModule/out_ready) in coordinate (west_svrs_out_data_ready) at (\x1,\y2);
\node [anchor=west,color=colorOUT] (svrs_out_data_ready) at (west_svrs_out_data_ready) {$\svrsOutReady$};
\path let \p1=(svrs_out_data_valid.west),\p2=(aesModule/out_data) in coordinate (west_svrs_out_data) at (\x1,\y2);
\node [anchor=west,color=colorOUT] (svrs_out_data) at (west_svrs_out_data) {$\svrsOutData$};
\node [draw,rectangle,xshift=1cm,anchor=west] (shares2sh_out) at (aesModule/out_data) {\texttt{shbus2shares}};

% randomness
\draw [line width=\sizeW, ->] (aesModule/rnd_ready) |- (prngMod/out_ready);
\draw [line width=\sizeW, ->] (prngMod/out_rnd) -| (aesModule/rnd);
\coordinate (loc_rnd_to_KU_tmp) at ($(prngMod/TR)+(\portOff,\portOff)$);
\path let \p1=(keyHolder/rnd_rfrsh), \p2=(arbitrer/prng_busy) in coordinate (anchor_rnd_ku) at ($(\x1,\y2)+(0,-2*\portOff)$);
\draw [line width=\sizeW, ->] (prngMod/out_rnd) -- ++(2*\portOff,0) |- (anchor_rnd_ku) -- (keyHolder/rnd_rfrsh);
% output
\draw [line width=\sizeW, ->, color=colorOUT] (aesModule/out_valid) |- (svrs_out_data_valid.west);
\draw [line width=\sizeW, ->, color=colorOUT] (aesModule/out_ready) |- (svrs_out_data_ready.west);
\draw [line width=\sizeW, color=colorOUT] (aesModule/out_data) -- (shares2sh_out.west);
\draw [line width=\sizeW, ->, color=colorOUT] (shares2sh_out.east) -- (svrs_out_data.west);


%%% Draw control top level Input port to arbitrer
\node [xshift=-2cm,anchor=east, color=colorKEY] (svrs_in_key_valid) at (arbitrer/in_key_valid) {\fontS \svrsKeyValid};
\node [xshift=-2cm,anchor=east, color=colorKEY] (svrs_in_key_ready) at (arbitrer/in_key_ready) {\fontS \svrsKeyReady};
\node [xshift=-2cm,anchor=east, color=colorIN] (svrs_in_data_valid) at (arbitrer/in_data_valid) {\fontS \svrsInValid};
\node [xshift=-2cm,anchor=east, color=colorIN] (svrs_in_data_ready) at (arbitrer/in_data_ready) {\fontS \svrsInReady};
\node [xshift=-2cm,anchor=east, color=colorSEED] (svrs_in_seed_valid) at (arbitrer/in_seed_valid) {\fontS \svrsSeedValid};
\node [xshift=-2cm,anchor=east, color=colorSEED] (svrs_in_seed_ready) at (arbitrer/in_seed_ready) {\fontS \svrsSeedReady};


%%% Internal connexion for Arbitrer <-> KSU
\draw [->, line width=\sizeW] (arbitrer/KSU_start_fetch) -- (keyHolder/start_fetch);
\draw [<-, line width=\sizeW] (arbitrer/KSU_in_ready) -- (keyHolder/data_in_ready);
\draw [<-, line width=\sizeW] (arbitrer/KSU_busy) -- (keyHolder/busy);
\draw [->, line width=\sizeW] (arbitrer/KSU_valid_in) -- (keyHolder/data_in_valid);
\path let \p1=(keyHolder/rnd_rfrsh), \p2=(keyHolder/last_key_required) in coordinate (anchor_lkey_req_KSU1) at ($(\x2,\y1)+(\portOff,-1)$);
\path let \p1=(keyHolder/data_in_valid), \p2=(arbitrer/KSU_lkey_req) in coordinate (anchor_lkey_req_KSU2) at ($(\x1,\y2)+(-\portOff,0)$);
\draw [->, line width=\sizeW] (keyHolder/last_key_required) -| (anchor_lkey_req_KSU1) -| (anchor_lkey_req_KSU2) -- (arbitrer/KSU_lkey_req);
\draw [fill=black] ($(keyHolder/last_key_required)+(\portOff,0)$) circle (\dotRad);

%%% Internal connexion for Arbitrer <-> AES
\pgfmathsetmacro{\internalAesOff}{\portOff*6}
\draw [->, line width=\sizeW] (arbitrer/aes_valid_in) -- ++(\internalAesOff+3*\portOff,0) |- (aesModule/in_valid);
\draw [<-, line width=\sizeW] (arbitrer/aes_in_ready) -- ++(\internalAesOff+2*\portOff,0) |- (aesModule/in_ready);
\draw [<-, line width=\sizeW] (arbitrer/aes_busy) -- ++(\internalAesOff+\portOff,0) |- (aesModule/busy);

%%% Internal connexion for Arbitrer <-> PRNG
\pgfmathsetmacro{\internalPRNGOff}{\portOff*1}
\path let \p1=(prngMod/out_valid), \p2=(anchor_rnd_ku) in coordinate (anchor_rnd_valid) at ($(\x1,\y2)+(\portOff,-\portOff)$);
\coordinate (anchor_rnd_valid2) at ($(arbitrer/prng_seeded)+(\internalPRNGOff+3*\portOff,0)$);
\draw [->, line width=\sizeW] (prngMod/out_valid) -| (anchor_rnd_valid) -| (anchor_rnd_valid2) -- (arbitrer/prng_seeded);
\draw [->, line width=\sizeW] (arbitrer/prng_start_reseed) -- ++(\internalPRNGOff+2*\portOff,0) |- (prngMod/start_reseed);
\draw [<-, line width=\sizeW] (arbitrer/prng_busy) -- ++(\internalPRNGOff+\portOff,0) |- (prngMod/busy);

%%%% Remaining of the port 
%%% Key 
\path let \p1=(svrs_in_key_valid.east), \p2=(keyHolder/data_in) in coordinate (east_svrs_in_key_data) at (\x1,\y2);
\node [anchor=east, color=colorKEY] at (east_svrs_in_key_data) (svrs_in_key_data)  {\fontS \svrsKey};
\path let \p1=(svrs_in_key_valid.east), \p2=(keyHolder/in_key_size_cfg) in coordinate (east_svrs_in_key_size_cfg) at (\x1,\y2);
\node [anchor=east, color=colorKEY] at (east_svrs_in_key_size_cfg) (svrs_in_key_size_cfg)  {\fontS \svrsKeySizeCfg};
\path let \p1=(svrs_in_key_valid.east), \p2=(keyHolder/in_mode_inverse) in coordinate (east_svrs_in_key_mode_inverse) at (\x1,\y2);
\node [anchor=east, color=colorKEY] at (east_svrs_in_key_mode_inverse) (svrs_in_key_mode_inverse)  {\fontS \svrsKeyModeInverse};

\draw[->, line width=\sizeW, color=colorKEY] (svrs_in_key_data.east) -- (keyHolder/data_in);
\draw[->, line width=\sizeW, color=colorKEY] (svrs_in_key_size_cfg.east) -- (keyHolder/in_key_size_cfg);
\draw[->, line width=\sizeW, color=colorKEY] (svrs_in_key_mode_inverse.east) -- (keyHolder/in_mode_inverse);
\draw[->, line width=\sizeW, color=colorKEY] (svrs_in_key_valid.east) -- (arbitrer/in_key_valid);
\draw[<-, line width=\sizeW, color=colorKEY] (svrs_in_key_ready.east) -- (arbitrer/in_key_ready);

%%% Seed
\path let \p1=(svrs_in_key_valid.east), \p2=(prngMod/in_seed) in coordinate (east_svrs_in_seed) at (\x1,\y2);
\node [anchor=east, color=colorSEED] at (east_svrs_in_seed) (svrs_in_seed)  {\fontS \svrsSeed};

\draw[->, line width=\sizeW, color=colorSEED] (svrs_in_seed_valid) -- (arbitrer/in_seed_valid);
\draw[<-, line width=\sizeW, color=colorSEED] (svrs_in_seed_ready) -- (arbitrer/in_seed_ready);
\draw[->, line width=\sizeW, color=colorSEED] (svrs_in_seed) -- (prngMod/in_seed);

%%% Data
\path let \p1=(aesModule/in_data), \p2=(prngMod/start_reseed) in coordinate (anchor_sh_in_data) at ($(\x2,\y1)+(-4*\portOff,0)$);
\path let \p1=(svrs_in_key_valid.east), \p2=(prngMod/start_reseed) in coordinate (east_svrs_in_data) at ($(\x1,\y2)+(0,\portOff)$);
\node [anchor=east, color=colorIN] at (east_svrs_in_data) (svrs_in_data)  {\fontS \svrsInData};

\node [draw,rectangle,xshift=5cm,anchor=west] (shares2sh_in) at (svrs_in_data) {\texttt{shares2shbus}};
\draw[->, line width=\sizeW, color=colorIN] (svrs_in_data.east) -- (shares2sh_in.west);
\draw[->, line width=\sizeW, color=colorIN] (shares2sh_in.east) -| (anchor_sh_in_data) -- (aesModule/in_data);


\draw[->, line width=\sizeW, color=colorIN] (svrs_in_data_valid) -- (arbitrer/in_data_valid);
\draw[<-, line width=\sizeW, color=colorIN] (svrs_in_data_ready) -- (arbitrer/in_data_ready);



